# 数据库表的三种关系

1. 一对一的关系(1:1):  在一表中有一条记录，则在另一张表中有一条记录相匹配。一般是看主表每一个字段对应另一张表的匹配记录条数。

   上图中学生实体与政治面貌实体是1：1的关系，一个学生只有一个政治面貌。(不能单纯的按数据库一对一的定义，查看一个政治面貌对应多个学生)

2. 一对多的关系：(1:N) 学生和精通专业之间就是1：N的关系，一个学生有多个精通专业。(反过来一个专业-------对应多少个同学没有意义！！)

   而且外键一般都是在N这个表中，就像上面的精通专业实体中的StuId-----------就是外键。

3. 多对多的关系：(M：N) 

    老师 -------学生：就是多对多的关系，一个老师可以有多个学生；相反一个学生也有多个老师!(这个反过来是有意义的所有可以反过来思考)！

所以，判断数据库表是什么关系：主要是通过通过业务需求来判断，不能单纯用数据库中对三种关系的定义(用一个表中的关联字段到另一个表中去查询看是1还是N个匹配记录，然后反过来用另一个表中的关联字段进行查询看有1还是N个匹配记录来判断是哪种关系)，例如 一个政治面貌对应多少个学生是没有意义的，所有一般是从主表到从表判断(如果反过来没有意义，就只看主表到从表查询是1还是N)。

 

外键跟三种关系的关联：数据库中一般用外键来表示1：1  1：N的关系，(外键在被引用表必须是主键)，所以1：1关系一般是在主表中建外键(上面的学生和政治面貌实体)；

而1：N关系则是在多的那个表建立外键(上面的学生实体和精通专业实体，在精通专业表中建立的外键)。

# 数据库隔离级别

* 读已提交隔离级别

读已提交是PostgreSQL里的缺省隔离级别。当一个事务运行在这个隔离级别时， SELECT查询(没有FOR UPDATE/SHARE子句)只能看到查询开始之前已提交的数据而无法看到未提交的数据或者在查询执行期间其它事务已提交的数据 。实际上，SELECT 查询看到一个在查询开始运行的瞬间该数据库的一个快照。 不过，SELECT看得见其自身所在事务中之前的更新执行的结果，即使它们尚未提交。请注意， 在同一个事务里两个相邻的SELECT命令可能看到不同的快照，因为其它事务会在第一个SELECT执行期间提交。